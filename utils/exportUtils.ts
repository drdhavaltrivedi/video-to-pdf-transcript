import { TrainingData } from "../types";

// Helper function to download a file
const downloadFile = (content: string, filename: string, mimeType: string) => {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
};

// Export as JSON
export const exportAsJSON = (data: TrainingData) => {
  try {
    const jsonContent = JSON.stringify(data, null, 2);
    const filename = `${data.metadata.title.replace(/\s+/g, '_')}_training_data.json`;
    downloadFile(jsonContent, filename, 'application/json');
  } catch (error) {
    console.error('Error exporting JSON:', error);
    alert('Failed to export JSON. Check console for details.');
  }
};

// Export as TXT
export const exportAsTXT = (data: TrainingData) => {
  try {
    const { metadata, transcript } = data;
    
    let txtContent = `AI Avatar Training Manifest\n`;
    txtContent += `Generated by AvatarTrain.ai â€¢ Vector Indexing Ready\n`;
    txtContent += `\n${'='.repeat(60)}\n\n`;
    
    txtContent += `TRAINING METADATA (INDEXING SCHEMA)\n`;
    txtContent += `${'-'.repeat(60)}\n`;
    txtContent += `Title: ${metadata.title}\n`;
    txtContent += `Target Persona: ${metadata.speakerName}\n`;
    txtContent += `Domain: ${metadata.category}\n`;
    txtContent += `Language: ${metadata.language}\n`;
    txtContent += `Index Tags: ${metadata.tags.join(", ")}\n`;
    txtContent += `\n${'='.repeat(60)}\n\n`;
    
    txtContent += `STRATEGIC CONTENT SUMMARY\n`;
    txtContent += `${'-'.repeat(60)}\n`;
    txtContent += `${metadata.summary}\n`;
    txtContent += `\n${'='.repeat(60)}\n\n`;
    
    txtContent += `VERBATIM EXTRACTION PREVIEW\n`;
    txtContent += `${'-'.repeat(60)}\n\n`;
    
    transcript.forEach((item, index) => {
      txtContent += `[${item.timestamp}] ${item.speaker}\n`;
      txtContent += `${item.text}\n`;
      txtContent += `Tone: ${item.tone} | Intent: ${item.intent}\n`;
      txtContent += `\n${'-'.repeat(60)}\n\n`;
    });
    
    const filename = `${metadata.title.replace(/\s+/g, '_')}_training_data.txt`;
    downloadFile(txtContent, filename, 'text/plain');
  } catch (error) {
    console.error('Error exporting TXT:', error);
    alert('Failed to export TXT. Check console for details.');
  }
};

// Export as CSV
export const exportAsCSV = (data: TrainingData) => {
  try {
    const { metadata, transcript } = data;
    
    // CSV header
    let csvContent = `Timestamp,Speaker,Text,Tone,Intent\n`;
    
    // Add transcript data
    transcript.forEach((item) => {
      const text = `"${item.text.replace(/"/g, '""')}"`; // Escape quotes in CSV
      csvContent += `${item.timestamp},"${item.speaker}",${text},"${item.tone}","${item.intent}"\n`;
    });
    
    // Add metadata as a separate section (commented out in CSV)
    csvContent += `\n# Metadata\n`;
    csvContent += `# Title,${metadata.title}\n`;
    csvContent += `# Speaker,${metadata.speakerName}\n`;
    csvContent += `# Category,${metadata.category}\n`;
    csvContent += `# Language,${metadata.language}\n`;
    csvContent += `# Tags,${metadata.tags.join("; ")}\n`;
    csvContent += `# Summary,"${metadata.summary.replace(/"/g, '""')}"\n`;
    
    const filename = `${metadata.title.replace(/\s+/g, '_')}_training_data.csv`;
    downloadFile(csvContent, filename, 'text/csv');
  } catch (error) {
    console.error('Error exporting CSV:', error);
    alert('Failed to export CSV. Check console for details.');
  }
};

