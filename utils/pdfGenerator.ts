
import { TrainingData } from "../types";

// Access jsPDF from window object (loaded via CDN)
declare global {
  interface Window {
    jspdf: any;
    jspdf_autotable: any;
  }
}

// Wait for jsPDF to be available
const waitForJsPDF = (): Promise<any> => {
  return new Promise((resolve, reject) => {
    if (typeof window === 'undefined') {
      reject(new Error('Window object not available'));
      return;
    }

    // Check multiple ways jsPDF might be exposed
    const getJsPDF = () => {
      // Try window.jspdf.jsPDF (UMD module)
      if (window.jspdf && window.jspdf.jsPDF) {
        return window.jspdf.jsPDF;
      }
      // Try window.jspdf directly
      if (window.jspdf && typeof window.jspdf === 'function') {
        return window.jspdf;
      }
      // Try global jspdf
      if ((window as any).jspdf && (window as any).jspdf.jsPDF) {
        return (window as any).jspdf.jsPDF;
      }
      return null;
    };

    // Check if already loaded
    const jsPDF = getJsPDF();
    if (jsPDF) {
      resolve(jsPDF);
      return;
    }

    // Wait for script to load (max 10 seconds)
    let attempts = 0;
    const maxAttempts = 100;
    const interval = setInterval(() => {
      attempts++;
      const jsPDF = getJsPDF();
      if (jsPDF) {
        clearInterval(interval);
        resolve(jsPDF);
      } else if (attempts >= maxAttempts) {
        clearInterval(interval);
        reject(new Error('jsPDF library failed to load. Please refresh the page.'));
      }
    }, 100);
  });
};

export const generateTranscriptPDF = async (data: TrainingData) => {
  try {
    console.log('Starting PDF generation...');
    
    // Wait for jsPDF to be available
    const jsPDF = await waitForJsPDF();
    
    if (!jsPDF) {
      throw new Error('jsPDF library not available');
    }
    const doc = new jsPDF();
    const { metadata, transcript } = data;

    // Global styling
    const primaryColor = [63, 81, 181]; // Indigo
    const secondaryColor = [241, 245, 249]; // Slate 100

    // 1. Header & Branding
    doc.setFontSize(22);
    doc.setTextColor(40, 44, 52);
    doc.text("AI Avatar Training Manifest", 14, 22);

    doc.setFontSize(10);
    doc.setTextColor(100);
    doc.text("Generated by AvatarTrain.ai • Vector Indexing Ready", 14, 28);

    // 2. Metadata Section (Vector DB Optimized)
    doc.setFillColor(...secondaryColor);
    doc.roundedRect(14, 34, 182, 45, 3, 3, 'F');

    doc.setFontSize(11);
    doc.setTextColor(40);
    doc.setFont(undefined, 'bold');
    doc.text("Training Metadata (Indexing Schema)", 18, 42);

    doc.setFont(undefined, 'normal');
    doc.setFontSize(9);
    doc.text(`Title: ${metadata.title}`, 18, 48);
    doc.text(`Target Persona: ${metadata.speakerName}`, 18, 53);
    doc.text(`Domain: ${metadata.category}`, 18, 58);
    doc.text(`Language: ${metadata.language}`, 18, 63);

    const tagsText = `Index Tags: ${metadata.tags.join(", ")}`;
    const splitTags = doc.splitTextToSize(tagsText, 170);
    doc.text(splitTags, 18, 68);

    // 3. Narrative Summary
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text("Strategic Content Summary", 14, 90);

    doc.setFont(undefined, 'normal');
    doc.setFontSize(10);
    const splitSummary = doc.splitTextToSize(metadata.summary, 180);
    doc.text(splitSummary, 14, 96);

    // 4. Granular Sentence-Level Transcript Table
    const tableData = transcript.map(s => [
      s.timestamp,
      s.speaker,
      s.text,
      `${s.tone}\n(${s.intent})`
    ]);

    const summaryHeight = (splitSummary.length * 5) + 10;

    (doc as any).autoTable({
      startY: 96 + summaryHeight,
      head: [['Time', 'Speaker', 'Transcript (Sentence Level)', 'Metadata']],
      body: tableData,
      theme: 'grid',
      headStyles: {
        fillColor: primaryColor,
        textColor: [255, 255, 255],
        fontSize: 10,
        fontStyle: 'bold'
      },
      columnStyles: {
        0: { cellWidth: 20, halign: 'center' },
        1: { cellWidth: 30, fontStyle: 'bold' },
        2: { cellWidth: 90 },
        3: { cellWidth: 42, fontSize: 8, textColor: [100, 100, 100] }
      },
      styles: {
        fontSize: 9,
        cellPadding: 4
      },
      alternateRowStyles: {
        fillColor: [250, 250, 250]
      }
    });

    // Footer on all pages
    const pageCount = (doc as any).internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text(`Page ${i} of ${pageCount} • Structured Training Data • CONFIDENTIAL`, 105, 290, { align: 'center' });
    }

    doc.save(`${metadata.title.replace(/\s+/g, '_')}_training_data.pdf`);
    console.log('PDF generated and download triggered successfully!');
  } catch (error) {
    console.error('Error generating PDF:', error);
    alert('Failed to generate PDF. Check console for details.');
  }
};
